# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.ConnectedVMwarevSphere/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_pools_create_request(
    resource_group_name: str, resource_pool_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/resourcePools/{resourcePoolName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "resourcePoolName": _SERIALIZER.url("resource_pool_name", resource_pool_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_pools_get_request(
    resource_group_name: str, resource_pool_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/resourcePools/{resourcePoolName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "resourcePoolName": _SERIALIZER.url("resource_pool_name", resource_pool_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_pools_update_request(
    resource_group_name: str, resource_pool_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/resourcePools/{resourcePoolName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "resourcePoolName": _SERIALIZER.url("resource_pool_name", resource_pool_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_pools_delete_request(
    resource_group_name: str,
    resource_pool_name: str,
    subscription_id: str,
    *,
    force: Optional[bool] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/resourcePools/{resourcePoolName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "resourcePoolName": _SERIALIZER.url("resource_pool_name", resource_pool_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_pools_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ConnectedVMwarevSphere/resourcePools"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_pools_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/resourcePools"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_clusters_create_request(
    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/clusters/{clusterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_clusters_get_request(
    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/clusters/{clusterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_clusters_update_request(
    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/clusters/{clusterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_clusters_delete_request(
    resource_group_name: str, cluster_name: str, subscription_id: str, *, force: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/clusters/{clusterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_clusters_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ConnectedVMwarevSphere/clusters"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_clusters_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/clusters"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_hosts_create_request(
    resource_group_name: str, host_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/hosts/{hostName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "hostName": _SERIALIZER.url("host_name", host_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_hosts_get_request(
    resource_group_name: str, host_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/hosts/{hostName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "hostName": _SERIALIZER.url("host_name", host_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_hosts_update_request(
    resource_group_name: str, host_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/hosts/{hostName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "hostName": _SERIALIZER.url("host_name", host_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_hosts_delete_request(
    resource_group_name: str, host_name: str, subscription_id: str, *, force: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/hosts/{hostName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "hostName": _SERIALIZER.url("host_name", host_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_hosts_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ConnectedVMwarevSphere/hosts"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_hosts_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/hosts"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_datastores_create_request(
    resource_group_name: str, datastore_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/datastores/{datastoreName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "datastoreName": _SERIALIZER.url("datastore_name", datastore_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_datastores_get_request(
    resource_group_name: str, datastore_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/datastores/{datastoreName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "datastoreName": _SERIALIZER.url("datastore_name", datastore_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_datastores_update_request(
    resource_group_name: str, datastore_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/datastores/{datastoreName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "datastoreName": _SERIALIZER.url("datastore_name", datastore_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_datastores_delete_request(
    resource_group_name: str, datastore_name: str, subscription_id: str, *, force: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/datastores/{datastoreName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "datastoreName": _SERIALIZER.url("datastore_name", datastore_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_datastores_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ConnectedVMwarevSphere/datastores"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_datastores_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/datastores"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vcenters_create_request(
    resource_group_name: str, vcenter_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_vcenters_get_request(
    resource_group_name: str, vcenter_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vcenters_update_request(
    resource_group_name: str, vcenter_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_vcenters_delete_request(
    resource_group_name: str, vcenter_name: str, subscription_id: str, *, force: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_vcenters_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ConnectedVMwarevSphere/vcenters"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vcenters_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_create_request(  # pylint: disable=name-too-long
    resource_group_name: str, virtual_machine_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_get_request(  # pylint: disable=name-too-long
    resource_group_name: str, virtual_machine_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, virtual_machine_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_delete_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    virtual_machine_template_name: str,
    subscription_id: str,
    *,
    force: Optional[bool] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineTemplates/{virtualMachineTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualMachineTemplateName": _SERIALIZER.url(
            "virtual_machine_template_name", virtual_machine_template_name, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_list_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineTemplates"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_templates_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineTemplates"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_create_request(
    resource_group_name: str, virtual_network_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_get_request(
    resource_group_name: str, virtual_network_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_update_request(
    resource_group_name: str, virtual_network_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_delete_request(
    resource_group_name: str,
    virtual_network_name: str,
    subscription_id: str,
    *,
    force: Optional[bool] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualNetworks/{virtualNetworkName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "virtualNetworkName": _SERIALIZER.url("virtual_network_name", virtual_network_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ConnectedVMwarevSphere/virtualNetworks"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_networks_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/virtualNetworks"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_create_request(
    resource_group_name: str, vcenter_name: str, inventory_item_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}/inventoryItems/{inventoryItemName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
        "inventoryItemName": _SERIALIZER.url("inventory_item_name", inventory_item_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_get_request(
    resource_group_name: str, vcenter_name: str, inventory_item_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}/inventoryItems/{inventoryItemName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
        "inventoryItemName": _SERIALIZER.url("inventory_item_name", inventory_item_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_delete_request(
    resource_group_name: str, vcenter_name: str, inventory_item_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}/inventoryItems/{inventoryItemName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
        "inventoryItemName": _SERIALIZER.url("inventory_item_name", inventory_item_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_inventory_items_list_by_v_center_request(  # pylint: disable=name-too-long
    resource_group_name: str, vcenter_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ConnectedVMwarevSphere/vcenters/{vcenterName}/inventoryItems"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
        "vcenterName": _SERIALIZER.url("vcenter_name", vcenter_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_create_or_update_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_get_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_update_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_delete_request(  # pylint: disable=name-too-long
    resource_uri: str, *, delete_from_host: Optional[bool] = None, force: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if delete_from_host is not None:
        _params["deleteFromHost"] = _SERIALIZER.query("delete_from_host", delete_from_host, "bool")
    if force is not None:
        _params["force"] = _SERIALIZER.query("force", force, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_list_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_stop_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/stop"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_start_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/start"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_virtual_machine_instances_restart_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/restart"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_hybrid_identity_metadata_get_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/hybridIdentityMetadata/default"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_hybrid_identity_metadata_list_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/hybridIdentityMetadata"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_guest_agents_create_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/guestAgents/default"
    )
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_guest_agents_get_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/guestAgents/default"
    )
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_guest_agents_delete_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/guestAgents/default"
    )
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_vm_instance_guest_agents_list_request(  # pylint: disable=name-too-long
    resource_uri: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceUri}/providers/Microsoft.ConnectedVMwarevSphere/virtualMachineInstances/default/guestAgents"
    path_format_arguments = {
        "resourceUri": _SERIALIZER.url("resource_uri", resource_uri, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Returns list of all operations.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "display": {
                        "description": "str",  # Optional. Description of the operation.
                        "operation": "str",  # Optional. Operation name.
                        "provider": "str",  # Optional. Provider name.
                        "resource": "str"  # Optional. Resource name.
                    },
                    "isDataAction": bool,  # Optional. Indicates whether the operation is data
                      action or not.
                    "name": "str"  # Optional. Name of the operation.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class ResourcePoolsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`resource_pools` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(
        self,
        resource_group_name: str,
        resource_pool_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_resource_pools_create_request(
            resource_group_name=resource_group_name,
            resource_pool_name=resource_pool_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        resource_pool_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements resourcePool PUT method.

        Create Or Update resourcePool.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        resource_pool_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements resourcePool PUT method.

        Create Or Update resourcePool.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        resource_pool_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements resourcePool PUT method.

        Create Or Update resourcePool.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                resource_pool_name=resource_pool_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, resource_pool_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a resourcePool.

        Implements resourcePool GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_resource_pools_get_request(
            resource_group_name=resource_group_name,
            resource_pool_name=resource_pool_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        resource_pool_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a resourcePool.

        API to update certain properties of the resourcePool resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        resource_pool_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a resourcePool.

        API to update certain properties of the resourcePool resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        resource_pool_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a resourcePool.

        API to update certain properties of the resourcePool resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_resource_pools_update_request(
            resource_group_name=resource_group_name,
            resource_pool_name=resource_pool_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, resource_pool_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_resource_pools_delete_request(
            resource_group_name=resource_group_name,
            resource_pool_name=resource_pool_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, resource_pool_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an resourcePool.

        Implements resourcePool DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param resource_pool_name: Name of the resourcePool. Required.
        :type resource_pool_name: str
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                resource_pool_name=resource_pool_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET resourcePools in a subscription.

        List of resourcePools in a subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_resource_pools_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET resourcePools in a resource group.

        List of resourcePools in a resource group.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuCapacityMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the pool in MHz.
                        "cpuLimitMHz": 0,  # Optional. Gets or sets CPULimitMHz which
                          specifies a CPU usage limit in MHz. Utilization will not exceed this limit
                          even if there are available resources.
                        "cpuOverallUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores on the pool in MHz.
                        "cpuReservationMHz": 0,  # Optional. Gets or sets CPUReservationMHz
                          which specifies the CPU size in MHz that is guaranteed to be available.
                        "cpuSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the CPU allocation level for this pool. This property is used
                          in relative allocation between resource consumers.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource pool.
                        "memCapacityGB": 0,  # Optional. Gets the total amount of physical
                          memory on the pool in GB.
                        "memLimitMB": 0,  # Optional. Gets or sets MemLimitMB specifies a
                          memory usage limit in megabytes. Utilization will not exceed the specified
                          limit even if there are available resources.
                        "memOverallUsageGB": 0,  # Optional. Gets the used physical memory on
                          the pool in GB.
                        "memReservationMB": 0,  # Optional. Gets or sets MemReservationMB
                          which specifies the guaranteed available memory in megabytes.
                        "memSharesLevel": "str",  # Optional. Gets or sets CPUSharesLevel
                          which specifies the memory allocation level for this pool. This property is
                          used in relative allocation between resource consumers.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource pool.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the resource pool.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this resource pool resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_resource_pools_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class ClustersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`clusters` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(
        self, resource_group_name: str, cluster_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_clusters_create_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements cluster PUT method.

        Create Or Update cluster.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements cluster PUT method.

        Create Or Update cluster.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def begin_create(
        self, resource_group_name: str, cluster_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements cluster PUT method.

        Create Or Update cluster.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a cluster.

        Implements cluster GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_clusters_get_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a cluster.

        API to update certain properties of the cluster resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a cluster.

        API to update certain properties of the cluster resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def update(
        self, resource_group_name: str, cluster_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a cluster.

        API to update certain properties of the cluster resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_clusters_update_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, cluster_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_clusters_delete_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, cluster_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an cluster.

        Implements cluster DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param cluster_name: Name of the cluster. Required.
        :type cluster_name: str
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET clusters in a subscription.

        List of clusters in a subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_clusters_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET clusters in a resource group.

        List of clusters in a resource group.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the cluster.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the cluster.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the cluster.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "totalCpuMHz": 0,  # Optional. Gets the max CPU usage across all
                          cores on the cluster in MHz.
                        "totalMemoryGB": 0,  # Optional. Gets the total amount of physical
                          memory on the cluster in GB.
                        "usedCpuMHz": 0,  # Optional. Gets the used CPU usage across all
                          cores on the cluster in MHz.
                        "usedMemoryGB": 0,  # Optional. Gets the used physical memory on the
                          cluster in GB.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this cluster resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_clusters_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class HostsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`hosts` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(
        self, resource_group_name: str, host_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_hosts_create_request(
            resource_group_name=resource_group_name,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        host_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements host PUT method.

        Create Or Update host.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        host_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements host PUT method.

        Create Or Update host.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def begin_create(
        self, resource_group_name: str, host_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements host PUT method.

        Create Or Update host.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                host_name=host_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, host_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a host.

        Implements host GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_hosts_get_request(
            resource_group_name=resource_group_name,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        host_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a host.

        API to update certain properties of the host resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        host_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a host.

        API to update certain properties of the host resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def update(
        self, resource_group_name: str, host_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a host.

        API to update certain properties of the host resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_hosts_update_request(
            resource_group_name=resource_group_name,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, host_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_hosts_delete_request(
            resource_group_name=resource_group_name,
            host_name=host_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, host_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an host.

        Implements host DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param host_name: Name of the host. Required.
        :type host_name: str
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                host_name=host_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET hosts in a subscription.

        List of hosts in a subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_hosts_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET hosts in a resource group.

        List of hosts in a resource group.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "cpuMhz": 0,  # Optional. Gets the max CPU usage across all cores in
                          MHz.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "datastoreIds": [
                            "str"  # Optional. Gets the datastore ARM ids.
                        ],
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the host.
                        "memorySizeGB": 0,  # Optional. Gets the total amount of physical
                          memory on the host in GB.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the host.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the host.
                        "networkIds": [
                            "str"  # Optional. Gets the network ARM ids.
                        ],
                        "overallCpuUsageMHz": 0,  # Optional. Gets the used CPU usage across
                          all cores in MHz.
                        "overallMemoryUsageGB": 0,  # Optional. Gets the used physical memory
                          on the host in GB.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this host resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_hosts_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class DatastoresOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`datastores` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(
        self,
        resource_group_name: str,
        datastore_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_datastores_create_request(
            resource_group_name=resource_group_name,
            datastore_name=datastore_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        datastore_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements datastore PUT method.

        Create Or Update datastore.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        datastore_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements datastore PUT method.

        Create Or Update datastore.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        datastore_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements datastore PUT method.

        Create Or Update datastore.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                datastore_name=datastore_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, datastore_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a datastore.

        Implements datastore GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datastores_get_request(
            resource_group_name=resource_group_name,
            datastore_name=datastore_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        datastore_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a datastore.

        API to update certain properties of the datastore resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        datastore_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a datastore.

        API to update certain properties of the datastore resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        datastore_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a datastore.

        API to update certain properties of the datastore resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_datastores_update_request(
            resource_group_name=resource_group_name,
            datastore_name=datastore_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, datastore_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datastores_delete_request(
            resource_group_name=resource_group_name,
            datastore_name=datastore_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, datastore_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an datastore.

        Implements datastore DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param datastore_name: Name of the datastore. Required.
        :type datastore_name: str
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                datastore_name=datastore_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET datastores in a subscription.

        List of datastores in a subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_datastores_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET datastores in a resource group.

        List of datastores in a resource group.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                          datastore in GBs.
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                          datastore in GBs.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the datastore.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the datastore.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the datastore.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this datastore resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_datastores_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VCentersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`vcenters` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(
        self, resource_group_name: str, vcenter_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_vcenters_create_request(
            resource_group_name=resource_group_name,
            vcenter_name=vcenter_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        vcenter_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements vCenter PUT method.

        Create Or Update vCenter.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        vcenter_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements vCenter PUT method.

        Create Or Update vCenter.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def begin_create(
        self, resource_group_name: str, vcenter_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements vCenter PUT method.

        Create Or Update vCenter.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                vcenter_name=vcenter_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, vcenter_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a vCenter.

        Implements vCenter GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_vcenters_get_request(
            resource_group_name=resource_group_name,
            vcenter_name=vcenter_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        vcenter_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a vCenter.

        API to update certain properties of the vCenter resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        vcenter_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a vCenter.

        API to update certain properties of the vCenter resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def update(
        self, resource_group_name: str, vcenter_name: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a vCenter.

        API to update certain properties of the vCenter resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_vcenters_update_request(
            resource_group_name=resource_group_name,
            vcenter_name=vcenter_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, vcenter_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_vcenters_delete_request(
            resource_group_name=resource_group_name,
            vcenter_name=vcenter_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, vcenter_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an vCenter.

        Implements vCenter DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                vcenter_name=vcenter_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET vCenters in a subscription.

        List of vCenters in a subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_vcenters_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET vCenters in a resource group.

        List of vCenters in a resource group.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "fqdn": "str",  # Gets or sets the FQDN/IPAddress of the vCenter.
                          Required.
                        "connectionStatus": "str",  # Optional. Gets or sets the connection
                          status to the vCenter.
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the vCenter.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the vCenter.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "instanceUuid": "str",  # Optional. Gets or sets the instance UUID of
                          the vCenter.
                        "port": 0,  # Optional. Gets or sets the port of the vCenter.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "version": "str"  # Optional. Gets or sets the version of the
                          vCenter.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_vcenters_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VirtualMachineTemplatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`virtual_machine_templates` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_virtual_machine_templates_create_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual machine template PUT method.

        Create Or Update virtual machine template.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual machine template PUT method.

        Create Or Update virtual machine template.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual machine template PUT method.

        Create Or Update virtual machine template.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                virtual_machine_template_name=virtual_machine_template_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, virtual_machine_template_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a virtual machine template.

        Implements virtual machine template GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_virtual_machine_templates_get_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a virtual machine template.

        API to update certain properties of the virtual machine template resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a virtual machine template.

        API to update certain properties of the virtual machine template resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a virtual machine template.

        API to update certain properties of the virtual machine template resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_virtual_machine_templates_update_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        *,
        force: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_virtual_machine_templates_delete_request(
            resource_group_name=resource_group_name,
            virtual_machine_template_name=virtual_machine_template_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        virtual_machine_template_name: str,
        *,
        force: Optional[bool] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an virtual machine template.

        Implements virtual machine template DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_machine_template_name: Name of the virtual machine template resource. Required.
        :type virtual_machine_template_name: str
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                virtual_machine_template_name=virtual_machine_template_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET virtualMachineTemplates in a subscription.

        List of virtualMachineTemplates in a subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_machine_templates_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET virtualMachineTemplates in a resource group.

        List of virtualMachineTemplates in a resource group.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "disks": [
                            {
                                "controllerKey": 0,  # Optional. Gets or sets the
                                  controller id.
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "deviceName": "str",  # Optional. Gets or sets the
                                  device name.
                                "diskMode": "str",  # Optional. Gets or sets the disk
                                  mode. Known values are: "persistent", "independent_persistent", and
                                  "independent_nonpersistent".
                                "diskObjectId": "str",  # Optional. Gets or sets the
                                  disk object id.
                                "diskSizeGB": 0,  # Optional. Gets or sets the disk
                                  total size.
                                "diskType": "str",  # Optional. Gets or sets the disk
                                  backing type. Known values are: "flat", "pmem", "rawphysical",
                                  "rawvirtual", "sparse", "sesparse", and "unknown".
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual disk in vCenter.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the virtual disk.
                                "unitNumber": 0  # Optional. Gets or sets the unit
                                  number of the disk on the controller.
                            }
                        ],
                        "firmwareType": "str",  # Optional. Firmware type. Known values are:
                          "bios" and "efi".
                        "folderPath": "str",  # Optional. Gets or sets the folder path of the
                          template.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual machine template.
                        "memorySizeMB": 0,  # Optional. Gets or sets memory size in MBs for
                          the template.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual machine template.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual machine template.
                        "networkInterfaces": [
                            {
                                "deviceKey": 0,  # Optional. Gets or sets the device
                                  key value.
                                "ipAddresses": [
                                    "str"  # Optional. Gets or sets the nic ip
                                      addresses.
                                ],
                                "ipSettings": {
                                    "allocationMethod": "str",  # Optional. Gets
                                      or sets the nic allocation method. Known values are: "unset",
                                      "dynamic", "static", "linklayer", "random", and "other".
                                    "dnsServers": [
                                        "str"  # Optional. Gets or sets the
                                          dns servers.
                                    ],
                                    "gateway": [
                                        "str"  # Optional. Gets or sets the
                                          gateway.
                                    ],
                                    "ipAddress": "str",  # Optional. Gets or sets
                                      the ip address for the nic.
                                    "ipAddressInfo": [
                                        {
                                            "allocationMethod": "str",  #
                                              Optional. Gets the ip address allocation method.
                                            "ipAddress": "str",  #
                                              Optional. Gets the ip address for the nic.
                                            "subnetMask": "str"  #
                                              Optional. Gets the mask.
                                        }
                                    ],
                                    "primaryWinsServer": "str",  # Optional. Gets
                                      or sets the primary server.
                                    "secondaryWinsServer": "str",  # Optional.
                                      Gets or sets the secondary server.
                                    "subnetMask": "str"  # Optional. Gets or sets
                                      the mask.
                                },
                                "label": "str",  # Optional. Gets or sets the label
                                  of the virtual network in vCenter that the nic is connected to.
                                "macAddress": "str",  # Optional. Gets or sets the
                                  NIC MAC address.
                                "name": "str",  # Optional. Gets or sets the name of
                                  the network interface.
                                "networkId": "str",  # Optional. Gets or sets the ARM
                                  Id of the network resource to connect the virtual machine.
                                "networkMoName": "str",  # Optional. Gets or sets the
                                  name of the virtual network in vCenter that the nic is connected to.
                                "networkMoRefId": "str",  # Optional. Gets or sets
                                  the vCenter MoRef (Managed Object Reference) ID of the virtual
                                  network that the nic is connected to.
                                "nicType": "str",  # Optional. NIC type. Known values
                                  are: "vmxnet3", "vmxnet2", "vmxnet", "e1000", "e1000e", and
                                  "pcnet32".
                                "powerOnBoot": "str"  # Optional. Gets or sets the
                                  power on boot. Known values are: "enabled" and "disabled".
                            }
                        ],
                        "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs for the
                          template.
                        "numCoresPerSocket": 0,  # Optional. Gets or sets the number of cores
                          per socket for the template. Defaults to 1 if unspecified.
                        "osName": "str",  # Optional. Gets or sets os name.
                        "osType": "str",  # Optional. Gets or sets the type of the os. Known
                          values are: "Windows", "Linux", and "Other".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "toolsVersion": "str",  # Optional. Gets or sets the current version
                          of VMware Tools.
                        "toolsVersionStatus": "str",  # Optional. Gets or sets the current
                          version status of VMware Tools installed in the guest operating system.
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_machine_templates_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VirtualNetworksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`virtual_networks` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_virtual_networks_create_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual network PUT method.

        Create Or Update virtual network.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual network PUT method.

        Create Or Update virtual network.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual network PUT method.

        Create Or Update virtual network.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                virtual_network_name=virtual_network_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, virtual_network_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a virtual network.

        Implements virtual network GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_virtual_networks_get_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a virtual network.

        API to update certain properties of the virtual network resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a virtual network.

        API to update certain properties of the virtual network resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        virtual_network_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Updates a virtual network.

        API to update certain properties of the virtual network resource.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_virtual_networks_update_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, virtual_network_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_virtual_networks_delete_request(
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
            subscription_id=self._config.subscription_id,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, virtual_network_name: str, *, force: Optional[bool] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an virtual network.

        Implements virtual network DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param virtual_network_name: Name of the virtual network resource. Required.
        :type virtual_network_name: str
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                virtual_network_name=virtual_network_name,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET virtualNetworks in a subscription.

        List of virtualNetworks in a subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_networks_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET virtualNetworks in a resource group.

        List of virtualNetworks in a resource group.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # Gets or sets the location. Required.
                    "properties": {
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the virtual network.
                        "moName": "str",  # Optional. Gets or sets the vCenter Managed Object
                          name for the virtual network.
                        "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                          (Managed Object Reference) ID for the virtual network.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str",  # Optional. Gets or sets a unique identifier for this
                          resource.
                        "vCenterId": "str"  # Optional. Gets or sets the ARM Id of the
                          vCenter resource in which this template resides.
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Gets or sets the Id.
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. Gets or sets the name.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets the Resource tags.
                    },
                    "type": "str"  # Optional. Gets or sets the type of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_networks_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class InventoryItemsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`inventory_items` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(
        self,
        resource_group_name: str,
        vcenter_name: str,
        inventory_item_name: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Implements InventoryItem PUT method.

        Create Or Update InventoryItem.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param inventory_item_name: Name of the inventoryItem. Required.
        :type inventory_item_name: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "inventoryType":

                # JSON input template for discriminator value "Cluster":
                inventory_item_properties = {
                    "inventoryType": "Cluster",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Datastore":
                inventory_item_properties = {
                    "inventoryType": "Datastore",
                    "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                      datastore, in GBs.
                    "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                      datastore, in GBs.
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Host":
                inventory_item_properties = {
                    "inventoryType": "Host",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "ResourcePool":
                inventory_item_properties = {
                    "inventoryType": "ResourcePool",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "cluster": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "folderPath": "str",  # Optional. Gets or sets the folder path of the vm.
                    "host": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "instanceUuid": "str",  # Optional. Gets or sets the instance uuid of the vm.
                    "ipAddresses": [
                        "str"  # Optional. Gets or sets the nic ip addresses.
                    ],
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "osName": "str",  # Optional. Gets or sets os name.
                    "osType": "str",  # Optional. Gets or sets the type of the os. Known values
                      are: "Windows", "Linux", and "Other".
                    "powerState": "str",  # Optional. Gets the power state of the virtual
                      machine.
                    "provisioningState": "str",  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                    "resourcePool": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS UUID of the vm.
                    "toolsRunningStatus": "str",  # Optional. Gets or sets the current running
                      status of VMware Tools running in the guest operating system.
                    "toolsVersion": "str",  # Optional. Gets or sets the current version of
                      VMware Tools.
                    "toolsVersionStatus": "str"  # Optional. Gets or sets the current version
                      status of VMware Tools installed in the guest operating system.
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": inventory_item_properties,
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cluster":
                inventory_item_properties = {
                    "inventoryType": "Cluster",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Datastore":
                inventory_item_properties = {
                    "inventoryType": "Datastore",
                    "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                      datastore, in GBs.
                    "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                      datastore, in GBs.
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Host":
                inventory_item_properties = {
                    "inventoryType": "Host",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "ResourcePool":
                inventory_item_properties = {
                    "inventoryType": "ResourcePool",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "cluster": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "folderPath": "str",  # Optional. Gets or sets the folder path of the vm.
                    "host": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "instanceUuid": "str",  # Optional. Gets or sets the instance uuid of the vm.
                    "ipAddresses": [
                        "str"  # Optional. Gets or sets the nic ip addresses.
                    ],
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "osName": "str",  # Optional. Gets or sets os name.
                    "osType": "str",  # Optional. Gets or sets the type of the os. Known values
                      are: "Windows", "Linux", and "Other".
                    "powerState": "str",  # Optional. Gets the power state of the virtual
                      machine.
                    "provisioningState": "str",  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                    "resourcePool": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS UUID of the vm.
                    "toolsRunningStatus": "str",  # Optional. Gets or sets the current running
                      status of VMware Tools running in the guest operating system.
                    "toolsVersion": "str",  # Optional. Gets or sets the current version of
                      VMware Tools.
                    "toolsVersionStatus": "str"  # Optional. Gets or sets the current version
                      status of VMware Tools installed in the guest operating system.
                }

                # response body for status code(s): 200
                response == {
                    "properties": inventory_item_properties,
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create(
        self,
        resource_group_name: str,
        vcenter_name: str,
        inventory_item_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Implements InventoryItem PUT method.

        Create Or Update InventoryItem.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param inventory_item_name: Name of the inventoryItem. Required.
        :type inventory_item_name: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cluster":
                inventory_item_properties = {
                    "inventoryType": "Cluster",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Datastore":
                inventory_item_properties = {
                    "inventoryType": "Datastore",
                    "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                      datastore, in GBs.
                    "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                      datastore, in GBs.
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Host":
                inventory_item_properties = {
                    "inventoryType": "Host",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "ResourcePool":
                inventory_item_properties = {
                    "inventoryType": "ResourcePool",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "cluster": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "folderPath": "str",  # Optional. Gets or sets the folder path of the vm.
                    "host": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "instanceUuid": "str",  # Optional. Gets or sets the instance uuid of the vm.
                    "ipAddresses": [
                        "str"  # Optional. Gets or sets the nic ip addresses.
                    ],
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "osName": "str",  # Optional. Gets or sets os name.
                    "osType": "str",  # Optional. Gets or sets the type of the os. Known values
                      are: "Windows", "Linux", and "Other".
                    "powerState": "str",  # Optional. Gets the power state of the virtual
                      machine.
                    "provisioningState": "str",  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                    "resourcePool": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS UUID of the vm.
                    "toolsRunningStatus": "str",  # Optional. Gets or sets the current running
                      status of VMware Tools running in the guest operating system.
                    "toolsVersion": "str",  # Optional. Gets or sets the current version of
                      VMware Tools.
                    "toolsVersionStatus": "str"  # Optional. Gets or sets the current version
                      status of VMware Tools installed in the guest operating system.
                }

                # response body for status code(s): 200
                response == {
                    "properties": inventory_item_properties,
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create(
        self,
        resource_group_name: str,
        vcenter_name: str,
        inventory_item_name: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Implements InventoryItem PUT method.

        Create Or Update InventoryItem.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param inventory_item_name: Name of the inventoryItem. Required.
        :type inventory_item_name: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "inventoryType":

                # JSON input template for discriminator value "Cluster":
                inventory_item_properties = {
                    "inventoryType": "Cluster",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Datastore":
                inventory_item_properties = {
                    "inventoryType": "Datastore",
                    "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                      datastore, in GBs.
                    "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                      datastore, in GBs.
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Host":
                inventory_item_properties = {
                    "inventoryType": "Host",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "ResourcePool":
                inventory_item_properties = {
                    "inventoryType": "ResourcePool",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "cluster": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "folderPath": "str",  # Optional. Gets or sets the folder path of the vm.
                    "host": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "instanceUuid": "str",  # Optional. Gets or sets the instance uuid of the vm.
                    "ipAddresses": [
                        "str"  # Optional. Gets or sets the nic ip addresses.
                    ],
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "osName": "str",  # Optional. Gets or sets os name.
                    "osType": "str",  # Optional. Gets or sets the type of the os. Known values
                      are: "Windows", "Linux", and "Other".
                    "powerState": "str",  # Optional. Gets the power state of the virtual
                      machine.
                    "provisioningState": "str",  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                    "resourcePool": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS UUID of the vm.
                    "toolsRunningStatus": "str",  # Optional. Gets or sets the current running
                      status of VMware Tools running in the guest operating system.
                    "toolsVersion": "str",  # Optional. Gets or sets the current version of
                      VMware Tools.
                    "toolsVersionStatus": "str"  # Optional. Gets or sets the current version
                      status of VMware Tools installed in the guest operating system.
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": inventory_item_properties,
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cluster":
                inventory_item_properties = {
                    "inventoryType": "Cluster",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Datastore":
                inventory_item_properties = {
                    "inventoryType": "Datastore",
                    "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                      datastore, in GBs.
                    "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                      datastore, in GBs.
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Host":
                inventory_item_properties = {
                    "inventoryType": "Host",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "ResourcePool":
                inventory_item_properties = {
                    "inventoryType": "ResourcePool",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "cluster": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "folderPath": "str",  # Optional. Gets or sets the folder path of the vm.
                    "host": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "instanceUuid": "str",  # Optional. Gets or sets the instance uuid of the vm.
                    "ipAddresses": [
                        "str"  # Optional. Gets or sets the nic ip addresses.
                    ],
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "osName": "str",  # Optional. Gets or sets os name.
                    "osType": "str",  # Optional. Gets or sets the type of the os. Known values
                      are: "Windows", "Linux", and "Other".
                    "powerState": "str",  # Optional. Gets the power state of the virtual
                      machine.
                    "provisioningState": "str",  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                    "resourcePool": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS UUID of the vm.
                    "toolsRunningStatus": "str",  # Optional. Gets or sets the current running
                      status of VMware Tools running in the guest operating system.
                    "toolsVersion": "str",  # Optional. Gets or sets the current version of
                      VMware Tools.
                    "toolsVersionStatus": "str"  # Optional. Gets or sets the current version
                      status of VMware Tools installed in the guest operating system.
                }

                # response body for status code(s): 200
                response == {
                    "properties": inventory_item_properties,
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_inventory_items_create_request(
            resource_group_name=resource_group_name,
            vcenter_name=vcenter_name,
            inventory_item_name=inventory_item_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, vcenter_name: str, inventory_item_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets InventoryItem.

        Implements InventoryItem GET method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param inventory_item_name: Name of the inventoryItem. Required.
        :type inventory_item_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cluster":
                inventory_item_properties = {
                    "inventoryType": "Cluster",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Datastore":
                inventory_item_properties = {
                    "inventoryType": "Datastore",
                    "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                      datastore, in GBs.
                    "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                      datastore, in GBs.
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Host":
                inventory_item_properties = {
                    "inventoryType": "Host",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "ResourcePool":
                inventory_item_properties = {
                    "inventoryType": "ResourcePool",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "cluster": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "folderPath": "str",  # Optional. Gets or sets the folder path of the vm.
                    "host": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "instanceUuid": "str",  # Optional. Gets or sets the instance uuid of the vm.
                    "ipAddresses": [
                        "str"  # Optional. Gets or sets the nic ip addresses.
                    ],
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "osName": "str",  # Optional. Gets or sets os name.
                    "osType": "str",  # Optional. Gets or sets the type of the os. Known values
                      are: "Windows", "Linux", and "Other".
                    "powerState": "str",  # Optional. Gets the power state of the virtual
                      machine.
                    "provisioningState": "str",  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                    "resourcePool": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS UUID of the vm.
                    "toolsRunningStatus": "str",  # Optional. Gets or sets the current running
                      status of VMware Tools running in the guest operating system.
                    "toolsVersion": "str",  # Optional. Gets or sets the current version of
                      VMware Tools.
                    "toolsVersionStatus": "str"  # Optional. Gets or sets the current version
                      status of VMware Tools installed in the guest operating system.
                }

                # response body for status code(s): 200
                response == {
                    "properties": inventory_item_properties,
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inventory_items_get_request(
            resource_group_name=resource_group_name,
            vcenter_name=vcenter_name,
            inventory_item_name=inventory_item_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, vcenter_name: str, inventory_item_name: str, **kwargs: Any
    ) -> None:
        """Deletes an inventoryItem.

        Implements inventoryItem DELETE method.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :param inventory_item_name: Name of the inventoryItem. Required.
        :type inventory_item_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_inventory_items_delete_request(
            resource_group_name=resource_group_name,
            vcenter_name=vcenter_name,
            inventory_item_name=inventory_item_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_v_center(self, resource_group_name: str, vcenter_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET inventoryItems in a vCenter.

        Returns the list of inventoryItems of the given vCenter.

        :param resource_group_name: The Resource Group Name. Required.
        :type resource_group_name: str
        :param vcenter_name: Name of the vCenter. Required.
        :type vcenter_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "inventoryType":

                # JSON input template for discriminator value "Cluster":
                inventory_item_properties = {
                    "inventoryType": "Cluster",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Datastore":
                inventory_item_properties = {
                    "inventoryType": "Datastore",
                    "capacityGB": 0,  # Optional. Gets or sets Maximum capacity of this
                      datastore, in GBs.
                    "freeSpaceGB": 0,  # Optional. Gets or sets Available space of this
                      datastore, in GBs.
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "Host":
                inventory_item_properties = {
                    "inventoryType": "Host",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "ResourcePool":
                inventory_item_properties = {
                    "inventoryType": "ResourcePool",
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "parent": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "provisioningState": "str"  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                }

                # JSON input template for discriminator value "VirtualMachine":
                inventory_item_properties = {
                    "inventoryType": "VirtualMachine",
                    "cluster": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "folderPath": "str",  # Optional. Gets or sets the folder path of the vm.
                    "host": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "instanceUuid": "str",  # Optional. Gets or sets the instance uuid of the vm.
                    "ipAddresses": [
                        "str"  # Optional. Gets or sets the nic ip addresses.
                    ],
                    "managedResourceId": "str",  # Optional. Gets or sets the tracked resource id
                      corresponding to the inventory resource.
                    "moName": "str",  # Optional. Gets or sets the vCenter Managed Object name
                      for the inventory item.
                    "moRefId": "str",  # Optional. Gets or sets the MoRef (Managed Object
                      Reference) ID for the inventory item.
                    "osName": "str",  # Optional. Gets or sets os name.
                    "osType": "str",  # Optional. Gets or sets the type of the os. Known values
                      are: "Windows", "Linux", and "Other".
                    "powerState": "str",  # Optional. Gets the power state of the virtual
                      machine.
                    "provisioningState": "str",  # Optional. Gets the provisioning state. Known
                      values are: "Succeeded", "Failed", "Canceled", "Provisioning", "Updating",
                      "Deleting", "Accepted", and "Created".
                    "resourcePool": {
                        "inventoryItemId": "str",  # Optional. Gets or sets the inventory
                          Item ID for the resource.
                        "inventoryType": "str",  # Optional. The inventory type. Known values
                          are: "ResourcePool", "VirtualMachine", "VirtualMachineTemplate",
                          "VirtualNetwork", "Cluster", "Datastore", and "Host".
                        "moName": "str"  # Optional. Gets or sets the vCenter Managed Object
                          name for the resource.
                    },
                    "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS UUID of the vm.
                    "toolsRunningStatus": "str",  # Optional. Gets or sets the current running
                      status of VMware Tools running in the guest operating system.
                    "toolsVersion": "str",  # Optional. Gets or sets the current version of
                      VMware Tools.
                    "toolsVersionStatus": "str"  # Optional. Gets or sets the current version
                      status of VMware Tools installed in the guest operating system.
                }

                # response body for status code(s): 200
                response == {
                    "properties": inventory_item_properties,
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "kind": "str",  # Optional. Metadata used by portal/tooling/etc to render
                      different UX experiences for resources of the same type; e.g. ApiApps are a kind
                      of Microsoft.Web/sites type.  If supported, the resource provider must validate
                      and persist this value.
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_inventory_items_list_by_v_center_request(
                    resource_group_name=resource_group_name,
                    vcenter_name=vcenter_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VirtualMachineInstancesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`virtual_machine_instances` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_or_update_initial(
        self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_virtual_machine_instances_create_or_update_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self, resource_uri: str, body: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual machine PUT method.

        The operation to create or update a virtual machine instance. Please note some properties can
        be set only during virtual machine instance creation.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_uri: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual machine PUT method.

        The operation to create or update a virtual machine instance. Please note some properties can
        be set only during virtual machine instance creation.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements virtual machine PUT method.

        The operation to create or update a virtual machine instance. Please note some properties can
        be set only during virtual machine instance creation.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_uri: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets a virtual machine.

        Retrieves information about a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_get_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _update_initial(
        self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_virtual_machine_instances_update_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self, resource_uri: str, body: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Updates a virtual machine.

        The operation to update a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Resource properties to update. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ]
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_uri: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Updates a virtual machine.

        The operation to update a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Resource properties to update. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Updates a virtual machine.

        The operation to update a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Resource properties to update. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ]
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_uri: str, *, delete_from_host: Optional[bool] = None, force: Optional[bool] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_delete_request(
            resource_uri=resource_uri,
            delete_from_host=delete_from_host,
            force=force,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_uri: str, *, delete_from_host: Optional[bool] = None, force: Optional[bool] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an virtual machine.

        The operation to delete a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :keyword delete_from_host: Whether to delete the VM from the vCenter. Default value is None.
        :paramtype delete_from_host: bool
        :keyword force: Whether force delete was specified. Default value is None.
        :paramtype force: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_uri=resource_uri,
                delete_from_host=delete_from_host,
                force=force,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, resource_uri: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements List virtual machine instances.

        Lists all of the virtual machine instances within the specified parent resource.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "hardwareProfile": {
                            "cpuHotAddEnabled": bool,  # Optional. Gets or sets a value
                              indicating whether virtual processors can be added while this virtual
                              machine is running.
                            "cpuHotRemoveEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether virtual processors can be removed while this
                              virtual machine is running.
                            "memoryHotAddEnabled": bool,  # Optional. Gets or sets a
                              value indicating whether memory can be added while this virtual machine
                              is running.
                            "memorySizeMB": 0,  # Optional. Gets or sets memory size in
                              MBs for the vm.
                            "numCPUs": 0,  # Optional. Gets or sets the number of vCPUs
                              for the vm.
                            "numCoresPerSocket": 0  # Optional. Gets or sets the number
                              of cores per socket for the vm. Defaults to 1 if unspecified.
                        },
                        "infrastructureProfile": {
                            "customResourceName": "str",  # Optional. Gets the name of
                              the corresponding resource in Kubernetes.
                            "firmwareType": "str",  # Optional. Firmware type. Known
                              values are: "bios" and "efi".
                            "folderPath": "str",  # Optional. Gets or sets the folder
                              path of the vm.
                            "instanceUuid": "str",  # Optional. Gets or sets the instance
                              uuid of the vm.
                            "inventoryItemId": "str",  # Optional. Gets or sets the
                              inventory Item ID for the virtual machine.
                            "moName": "str",  # Optional. Gets or sets the vCenter
                              Managed Object name for the virtual machine.
                            "moRefId": "str",  # Optional. Gets or sets the vCenter MoRef
                              (Managed Object Reference) ID for the virtual machine.
                            "smbiosUuid": "str",  # Optional. Gets or sets the SMBIOS
                              UUID of the vm.
                            "templateId": "str",  # Optional. Gets or sets the ARM Id of
                              the template resource to deploy the virtual machine.
                            "vCenterId": "str"  # Optional. Gets or sets the ARM Id of
                              the vCenter resource in which this resource pool resides.
                        },
                        "networkProfile": {
                            "networkInterfaces": [
                                {
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "ipAddresses": [
                                        "str"  # Optional. Gets or sets the
                                          nic ip addresses.
                                    ],
                                    "ipSettings": {
                                        "allocationMethod": "str",  #
                                          Optional. Gets or sets the nic allocation method. Known
                                          values are: "unset", "dynamic", "static", "linklayer",
                                          "random", and "other".
                                        "dnsServers": [
                                            "str"  # Optional. Gets or
                                              sets the dns servers.
                                        ],
                                        "gateway": [
                                            "str"  # Optional. Gets or
                                              sets the gateway.
                                        ],
                                        "ipAddress": "str",  # Optional. Gets
                                          or sets the ip address for the nic.
                                        "ipAddressInfo": [
                                            {
                                                "allocationMethod":
                                                  "str",  # Optional. Gets the ip address allocation
                                                  method.
                                                "ipAddress": "str",
                                                  # Optional. Gets the ip address for the nic.
                                                "subnetMask": "str"
                                                  # Optional. Gets the mask.
                                            }
                                        ],
                                        "primaryWinsServer": "str",  #
                                          Optional. Gets or sets the primary server.
                                        "secondaryWinsServer": "str",  #
                                          Optional. Gets or sets the secondary server.
                                        "subnetMask": "str"  # Optional. Gets
                                          or sets the mask.
                                    },
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual network in vCenter that the nic is connected
                                      to.
                                    "macAddress": "str",  # Optional. Gets or
                                      sets the NIC MAC address.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the network interface.
                                    "networkId": "str",  # Optional. Gets or sets
                                      the ARM Id of the network resource to connect the virtual
                                      machine.
                                    "networkMoName": "str",  # Optional. Gets or
                                      sets the name of the virtual network in vCenter that the nic is
                                      connected to.
                                    "networkMoRefId": "str",  # Optional. Gets or
                                      sets the vCenter MoRef (Managed Object Reference) ID of the
                                      virtual network that the nic is connected to.
                                    "nicType": "str",  # Optional. NIC type.
                                      Known values are: "vmxnet3", "vmxnet2", "vmxnet", "e1000",
                                      "e1000e", and "pcnet32".
                                    "powerOnBoot": "str"  # Optional. Gets or
                                      sets the power on boot. Known values are: "enabled" and
                                      "disabled".
                                }
                            ]
                        },
                        "osProfile": {
                            "adminPassword": "str",  # Optional. Sets administrator
                              password.
                            "adminUsername": "str",  # Optional. Gets or sets
                              administrator username.
                            "computerName": "str",  # Optional. Gets or sets computer
                              name.
                            "guestId": "str",  # Optional. Gets or sets the guestId.
                            "osSku": "str",  # Optional. Gets or sets os sku.
                            "osType": "str",  # Optional. Gets or sets the type of the
                              os. Known values are: "Windows", "Linux", and "Other".
                            "toolsRunningStatus": "str",  # Optional. Gets or sets the
                              current running status of VMware Tools running in the guest operating
                              system.
                            "toolsVersion": "str",  # Optional. Gets or sets the current
                              version of VMware Tools.
                            "toolsVersionStatus": "str"  # Optional. Gets or sets the
                              current version status of VMware Tools installed in the guest operating
                              system.
                        },
                        "placementProfile": {
                            "clusterId": "str",  # Optional. Gets or sets the ARM Id of
                              the cluster resource on which this virtual machine will deploy.
                            "datastoreId": "str",  # Optional. Gets or sets the ARM Id of
                              the datastore resource on which the data for the virtual machine will be
                              kept.
                            "hostId": "str",  # Optional. Gets or sets the ARM Id of the
                              host resource on which this virtual machine will deploy.
                            "resourcePoolId": "str"  # Optional. Gets or sets the ARM Id
                              of the resourcePool resource on which this virtual machine will deploy.
                        },
                        "powerState": "str",  # Optional. Gets the power state of the virtual
                          machine.
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "resourceUid": "str",  # Optional. Gets or sets a unique identifier
                          for the vm resource.
                        "securityProfile": {
                            "uefiSettings": {
                                "secureBootEnabled": bool  # Optional. Specifies
                                  whether secure boot should be enabled on the virtual machine.
                            }
                        },
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "storageProfile": {
                            "disks": [
                                {
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the controller id.
                                    "deviceKey": 0,  # Optional. Gets or sets the
                                      device key value.
                                    "deviceName": "str",  # Optional. Gets or
                                      sets the device name.
                                    "diskMode": "str",  # Optional. Gets or sets
                                      the disk mode. Known values are: "persistent",
                                      "independent_persistent", and "independent_nonpersistent".
                                    "diskObjectId": "str",  # Optional. Gets or
                                      sets the disk object id.
                                    "diskSizeGB": 0,  # Optional. Gets or sets
                                      the disk total size.
                                    "diskType": "str",  # Optional. Gets or sets
                                      the disk backing type. Known values are: "flat", "pmem",
                                      "rawphysical", "rawvirtual", "sparse", "sesparse", and "unknown".
                                    "label": "str",  # Optional. Gets or sets the
                                      label of the virtual disk in vCenter.
                                    "name": "str",  # Optional. Gets or sets the
                                      name of the virtual disk.
                                    "unitNumber": 0  # Optional. Gets or sets the
                                      unit number of the disk on the controller.
                                }
                            ],
                            "scsiControllers": [
                                {
                                    "busNumber": 0,  # Optional. Gets or sets the
                                      bus number of the controller.
                                    "controllerKey": 0,  # Optional. Gets or sets
                                      the key of the controller.
                                    "scsiCtlrUnitNumber": 0,  # Optional. Gets or
                                      sets the SCSI controller unit number.
                                    "sharing": "str",  # Optional. Gets or sets
                                      the sharing mode. Known values are: "noSharing",
                                      "physicalSharing", and "virtualSharing".
                                    "type": "str"  # Optional. Gets or sets the
                                      controller type. Known values are: "lsilogic", "buslogic",
                                      "pvscsi", and "lsilogicsas".
                                }
                            ]
                        }
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_virtual_machine_instances_list_request(
                    resource_uri=resource_uri,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _stop_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_virtual_machine_instances_stop_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @overload
    def begin_stop(
        self, resource_uri: str, body: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        # pylint: disable=line-too-long
        """Implements the operation to stop a virtual machine.

        The operation to power off (stop) a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Virtualmachine stop action payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "skipShutdown": False  # Optional. Default value is False. Gets or sets a
                      value indicating whether to request non-graceful VM shutdown. True value for this
                      flag indicates non-graceful shutdown whereas false indicates otherwise. Defaults
                      to false.
                }
        """

    @overload
    def begin_stop(
        self,
        resource_uri: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Implements the operation to stop a virtual machine.

        The operation to power off (stop) a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Virtualmachine stop action payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_stop(
        self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> LROPoller[None]:
        # pylint: disable=line-too-long
        """Implements the operation to stop a virtual machine.

        The operation to power off (stop) a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Virtualmachine stop action payload. Is either a JSON type or a IO[bytes] type.
         Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "skipShutdown": False  # Optional. Default value is False. Gets or sets a
                      value indicating whether to request non-graceful VM shutdown. True value for this
                      flag indicates non-graceful shutdown whereas false indicates otherwise. Defaults
                      to false.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._stop_initial(  # type: ignore
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _start_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_uri: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_start_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_start(self, resource_uri: str, **kwargs: Any) -> LROPoller[None]:
        """Implements the operation to start a virtual machine.

        The operation to start a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._start_initial(  # type: ignore
                resource_uri=resource_uri, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _restart_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_uri: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_virtual_machine_instances_restart_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_restart(self, resource_uri: str, **kwargs: Any) -> LROPoller[None]:
        """Implements the operation to restart a virtual machine.

        The operation to restart a virtual machine instance.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._restart_initial(  # type: ignore
                resource_uri=resource_uri, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class VmInstanceHybridIdentityMetadataOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`vm_instance_hybrid_identity_metadata` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_uri: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets HybridIdentityMetadata.

        Implements HybridIdentityMetadata GET method.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "publicKey": "str",  # Optional. Gets or sets the Public Key.
                        "resourceUid": "str"  # Optional. The unique identifier for the
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_vm_instance_hybrid_identity_metadata_get_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def list(self, resource_uri: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET HybridIdentityMetadata in a vm.

        Returns the list of HybridIdentityMetadata of the given vm.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "publicKey": "str",  # Optional. Gets or sets the Public Key.
                        "resourceUid": "str"  # Optional. The unique identifier for the
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_vm_instance_hybrid_identity_metadata_list_request(
                    resource_uri=resource_uri,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class VMInstanceGuestAgentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.connectedvmware.AzureArcVMwareManagementServiceAPI`'s
        :attr:`vm_instance_guest_agents` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_initial(self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_vm_instance_guest_agents_create_request(
            resource_uri=resource_uri,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self, resource_uri: str, body: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements GuestAgent PUT method.

        Create Or Update GuestAgent.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Request payload. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": {
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the guest.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the guest.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "httpProxyConfig": {
                            "httpsProxy": "str"  # Optional. Gets or sets httpsProxy url.
                        },
                        "privateLinkScopeResourceId": "str",  # Optional. The resource id of
                          the private link scope this machine is assigned to, if any.
                        "provisioningAction": "str",  # Optional. Gets or sets the guest
                          agent provisioning action. Known values are: "install", "uninstall", and
                          "repair".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "status": "str",  # Optional. Gets or sets the guest agent status.
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str"  # Optional. Gets or sets a unique identifier for this
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "properties": {
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the guest.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the guest.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "httpProxyConfig": {
                            "httpsProxy": "str"  # Optional. Gets or sets httpsProxy url.
                        },
                        "privateLinkScopeResourceId": "str",  # Optional. The resource id of
                          the private link scope this machine is assigned to, if any.
                        "provisioningAction": "str",  # Optional. Gets or sets the guest
                          agent provisioning action. Known values are: "install", "uninstall", and
                          "repair".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "status": "str",  # Optional. Gets or sets the guest agent status.
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str"  # Optional. Gets or sets a unique identifier for this
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_uri: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements GuestAgent PUT method.

        Create Or Update GuestAgent.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Request payload. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "properties": {
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the guest.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the guest.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "httpProxyConfig": {
                            "httpsProxy": "str"  # Optional. Gets or sets httpsProxy url.
                        },
                        "privateLinkScopeResourceId": "str",  # Optional. The resource id of
                          the private link scope this machine is assigned to, if any.
                        "provisioningAction": "str",  # Optional. Gets or sets the guest
                          agent provisioning action. Known values are: "install", "uninstall", and
                          "repair".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "status": "str",  # Optional. Gets or sets the guest agent status.
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str"  # Optional. Gets or sets a unique identifier for this
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self, resource_uri: str, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Implements GuestAgent PUT method.

        Create Or Update GuestAgent.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :param body: Request payload. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "properties": {
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the guest.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the guest.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "httpProxyConfig": {
                            "httpsProxy": "str"  # Optional. Gets or sets httpsProxy url.
                        },
                        "privateLinkScopeResourceId": "str",  # Optional. The resource id of
                          the private link scope this machine is assigned to, if any.
                        "provisioningAction": "str",  # Optional. Gets or sets the guest
                          agent provisioning action. Known values are: "install", "uninstall", and
                          "repair".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "status": "str",  # Optional. Gets or sets the guest agent status.
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str"  # Optional. Gets or sets a unique identifier for this
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "properties": {
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the guest.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the guest.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "httpProxyConfig": {
                            "httpsProxy": "str"  # Optional. Gets or sets httpsProxy url.
                        },
                        "privateLinkScopeResourceId": "str",  # Optional. The resource id of
                          the private link scope this machine is assigned to, if any.
                        "provisioningAction": "str",  # Optional. Gets or sets the guest
                          agent provisioning action. Known values are: "install", "uninstall", and
                          "repair".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "status": "str",  # Optional. Gets or sets the guest agent status.
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str"  # Optional. Gets or sets a unique identifier for this
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_uri=resource_uri,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_uri: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Gets GuestAgent.

        Implements GuestAgent GET method.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the guest.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the guest.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "httpProxyConfig": {
                            "httpsProxy": "str"  # Optional. Gets or sets httpsProxy url.
                        },
                        "privateLinkScopeResourceId": "str",  # Optional. The resource id of
                          the private link scope this machine is assigned to, if any.
                        "provisioningAction": "str",  # Optional. Gets or sets the guest
                          agent provisioning action. Known values are: "install", "uninstall", and
                          "repair".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "status": "str",  # Optional. Gets or sets the guest agent status.
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str"  # Optional. Gets or sets a unique identifier for this
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_vm_instance_guest_agents_get_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_uri: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_vm_instance_guest_agents_delete_request(
            resource_uri=resource_uri,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(self, resource_uri: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes an GuestAgent.

        Implements GuestAgent DELETE method.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_uri=resource_uri, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, resource_uri: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """Implements GET GuestAgent in a vm.

        Returns the list of GuestAgent of the given vm.

        :param resource_uri: The fully qualified Azure Resource manager identifier of the Hybrid
         Compute machine resource to be extended. Required.
        :type resource_uri: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "credentials": {
                            "password": "str",  # Optional. Gets or sets the password to
                              connect with the guest.
                            "username": "str"  # Optional. Gets or sets username to
                              connect with the guest.
                        },
                        "customResourceName": "str",  # Optional. Gets the name of the
                          corresponding resource in Kubernetes.
                        "httpProxyConfig": {
                            "httpsProxy": "str"  # Optional. Gets or sets httpsProxy url.
                        },
                        "privateLinkScopeResourceId": "str",  # Optional. The resource id of
                          the private link scope this machine is assigned to, if any.
                        "provisioningAction": "str",  # Optional. Gets or sets the guest
                          agent provisioning action. Known values are: "install", "uninstall", and
                          "repair".
                        "provisioningState": "str",  # Optional. Gets the provisioning state.
                          Known values are: "Succeeded", "Failed", "Canceled", "Provisioning",
                          "Updating", "Deleting", "Accepted", and "Created".
                        "status": "str",  # Optional. Gets or sets the guest agent status.
                        "statuses": [
                            {
                                "lastUpdatedAt": "2020-02-20 00:00:00",  # Optional.
                                  The last update time for this condition.
                                "message": "str",  # Optional. A human readable
                                  message indicating details about the status.
                                "reason": "str",  # Optional. The reason for the
                                  condition's status.
                                "severity": "str",  # Optional. Severity with which
                                  to treat failures of this type of condition.
                                "status": "str",  # Optional. Status of the
                                  condition.
                                "type": "str"  # Optional. The type of the condition.
                            }
                        ],
                        "uuid": "str"  # Optional. Gets or sets a unique identifier for this
                          resource.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_vm_instance_guest_agents_list_request(
                    resource_uri=resource_uri,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)
